본 프로젝트 설명

[1] 프로젝트 폴더 설명
pio_tcp_mqtt_ota_v03 폴더는 볼필요 없음.
pio_Luxtep_03와 proc_tcp_mqtt_ota_v03 폴더를 보면 된다. 혹시 그 안에 zip 파일이 있다면 그건 백업이니 신경쓰지 않는다.
pio_Luxtep_03 프로젝트의 별칭을 "esp32"혹은 "TCP 클라이언트"로 한다. esp32-s3 머신용 코드고 vscode의 platformio 기반의 코드다. 
proc_tcp_mqtt_ota_v03 프로젝트의 별칭을 "TCP서버" 혹은 "서버"로 한다. 서버는 Processing IDE 기반으로 제작되었다.

[2] esp32 회로 기판에 대한 설명
Resource 폴더 안의 파일 목록과 그 내용은 아래와 같다.
MDLL-24-6822 Schematic 20241108.PDF : 회로도
MDLL-24-6822 Assembly 20241107.PDF : 부품배치도
Part List MDLL-24-6822 Rev1.0 20241112.xlsx : BOM
Pick Place for MDLL-24-6822.csv : PNP
MG0622M-Final.pdf : 자석커넥터 - male
MG0622F-Final.pdf : 자석커넥터 - female

gpio 8번, 47번을 333옴으로 연결후 47번핀 disable.jpg : 333옴 땜빵 저항 사진
image-dip, tact, buzzer.jpg : 딥스위치, 택트, buzzer의 사진과 설명
luxtep-밟은사진-01.jpg : 센서를 발로 밟았을때 LED가 켜진 모습의 스크린샷
USB PD trigger module.jpg : USB PD 전원 쪽보드 이미지

시연 동영상 - 발로 밟았을때에 LED에 불이 들어온 영상) https://www.youtube.com/watch?v=Cc8t9BERNs0

주요 부품 : 
SP : 가로28 x 세로34 = 952개짜리 매트릭스. ==> 회로도 상의 SP는 Sensing point라는 의미. 실제 부품이 아니라 단자 2개짜리 패턴이다. 패턴 안테나와 유사한데 단자가 2개. 이 부위에 conductive film을 붙여서 누르면 단자 2개 사이의 저항이 변한다. 세게 누를 수록 저항이 떨어진다. 한쪽 단자에 voltage를 인가하고 다른 한쪽 단자에 adc를 물려서 전압을 측정한다. 이때 행과 열을 mux를 통해서 선택한다. 그리고 'matrix switch scan encoding ghost' 현상 - 매트릭스 배열의 스위치에서 직사각형의 네 꼭지점 중에 세 지점의 스위치를 누르면, 나머지 한 지점이 눌린것처럼 on이 측정되는 현상 - 을 방지하기 위해서 전류와 저항을 따로 측정해서 전압을 산출하고 있다. 계산으로 도출된 전압값에 약간의 보정을 하는데, 이 전압값을 곧 힘(압력)의 세기로 사실상 간주하고 있다.

LED 매트릭스: 가로28 x 세로35 = 980개. ==> 압력의 세기에 따라 컬러를 변경해준다. 센서 1개당 위아래 2개의 LED가 켜진다. 윗줄의 센서와 아랫줄의 센서는 가운데에 있는 1줄의 LED를 공유하는 셈이다. 가운데 줄의 LED는 위쪽 센서를 누를땐 '아랫쪽 LED'로서 켜지고, 아랫줄의 센서를 누르면 가웃데 줄의 LED는 '윗쪽 LED'로서 켜진다.
LED indicator : wifi, tcp, ota 관련하여 status와 error를 표시해주는 용도.

전체 구성 : 
<6핀 자석 커넥터>
전원 2핀, GND 2핀, D+, D- 로 구성. 이걸로 전원 체인과 통신 체인을 구성함.

<전원 체인>
1개의 master board (board id : 0)에 7개의 slave board(board id : 1~7)가 magnetic 단자로 연결되는 구조.
<주의!> USB PD 100W 전원 잭을 USB PD 전원 쪽보드에 꽂는다. 그 쪽보드와 0번 보드는 전선으로 연결되어 있다. 암튼 USB전원은 0번에 인가되며, 자석 커넥터를 통해서 1, 2, 3~7번까지 전원이 전달된다.
이 전원의 전류는 대부분 LED구동에 소모된다.

<통신 체인>
0~7번 보드는 rs485로 물려있다. 통신선은 6핀 자석 커넥터의 D+, D-를 이용한다.

<사소한 부품>
dip switch 2개 : 2채널, 4채널짜리 딥스위치가 존재. 2채널짜리 딥스위치는 통신 모드 설정 (1:serial/0:wifi)와 max board id 설정(0:1, 1:7).  4채널짜리 딥스위치는 이진수로 취급하여, 0~15까지의 board id를 설정할수 있음.
택트 스위치 3개 : ota모드 진입, LED 스크린샷, Blur on/off 등을 처리. 
Buzzer 2개 : 아직 적절한 사용처가 없음.

< 설계 오류와 해결책 > 첨부한 회로도에 오류가 있어서 아래와 같이 임시 수정을 해서 사용 중이다. 
퓨즈: 너무 낮은 사양이라서 전원을 꼽자마자 망가짐. 해결책: 퓨즈 양단 간을 굵은 전선으로 연결해서 사용중.
LED 0번 strip용 핀 설정 오류 : 47번핀으로 설계했지만 오동작함. 해결책: firmware에서 47번을 disable 시켰음. 대신 8번핀을 사용중. 전선으로 47번핀과 8번핀을 연결해서 사용중.
LED 0번 strip의 동작 오류 : LED 컬러에서 웬지 1개씩 밀린듯이 표현됨. 해결책: 333ohm 저항을 추가했음. 저항을 땜질할 단자가 부족한 이유로, 8번핀과 47번핀을 333옴짜리 저항으로 연결함. 47번핀이 disable되어 있기 때문에 8번핀에 333옴을 연결한 것과 마찬가지이다.



[3] esp32쪽 펌웨어 동작 시나리오는 크게 다음과 같다.
주요(main) 동작 : 
 - 952 센서 포인트의 adc 측정, 
 - 980개의 LED 표현. 
 - 센서 데이터를 tcp로 전송, 
 - LED에 표현할 추가 layer(OSD)를 tcp로 수신
 - OTA 2가지(OTA direct, OTA firebase)
 - MQTT 구독 - 서버가 reboot할때 dhcp 서버로부터 부여 받는 IP가 변경되는데. 변경되는 IP를 esp32에게 알려주기 위해 MQTT Pub/Sub 기능을 이용함.

사소한(trivial) 동작 : 부저 소리내기, 인디케이터 LED 2개, 버튼 3개 입력 받기.

마스터 : 보드 번호를 0번으로 부여한다.
슬레이브 : 보드 번호를 1~7번으로 부여한다.


< 압력 센서와 LED의 연동 동작 >
가장 중요한 동작이다. 압력센서와 LED가 교차배치되어 있다. 압력센서는 학술적으로는 FSR(Force sensitive resistor)라고 부른다.

압력 센서 배열 : 가로28 x 세로34 = 952개짜리 매트릭스. 좌표로 따지면 x는 0~27이고 y는 0~33이다.
LED 배열 : 가로28 x 세로35 = 980개짜리 매트릭스.  좌표로 따지면 x는 0~27이고 y는 0~34이다.
LED 가로줄과 센서 가로줄이 번갈아 배치가 되어 있다.
LED Y = 0은 맨 아래이고, LED Y=1은 그 바로 위에 배치되어 있다.
센서 Y=0은 LED Y=0인 줄과 Y=1인 줄의 사이에 존재하는 셈이다..

예를 들어보면. 압력 센서 (3, 8)을 세게 누르면 ADC 측정값이 증가한다.
그러면 그 센서의 바로 아래(3, 8)와 위(3, 9)에 존재하는 LED의 색상을 변경시켜준다..
만일 blur mode일 경우에는 그 2개 LED 주변 6개의 LED 색상도 같이 바뀐다..

<압력 센서 데이터 전송 >
전송은 크게 intra 전송과 inter 전송이 있다.
<inter 전송>
자석 커넥터에 물려있는 MCU들끼리 rs485를 통해 통신한다. 

<intra 전송>
외부와의 통신이 여러가지가 있다.

<패킷의 기본 구조>
tcp 패킷은 기본적으로 8바이트의 헤더와 2바이트의 테일을 가진다.
헤더는 반드시 0xff, 0xff로 시작된다. 테일은 반드시 0xfe로 끝난다.

pc용 어플리케이션의 tcp서버 1대가 8개의 클라이언트와 연결되어 tcp로 데이터를 주고받도록 설계되어 있다.

esp32는 주로 측정값을 pc에 전송한다. 센서가 952(28*34)개이므로 헤더와 테일을 더하면 8(header) + 952(센서 측정값) + 2(tail) = 962바이트의 길이를 갖는다.
반면에 pc는 esp32에게 OSD용 led 값을 보내준다. led가 980(28*35)개인데, 헤더와 테일 외에, subheader를 가진다. subheader는 8바이트의 길이인데, osd 버퍼의 위치와 크기를 설명한다.
osd 패킷의 최대 길이는 8(header) + 8(sub header) + 980(led데이터) + 2(tail) 이다.
osd 패킷의 길이는 가변이다. osd패킷의 헤더에는 헤더를 제외한 전체 패킷의 사이즈 길이가 담겨져 있다. 예를 들어 전체 패킷이 420바이트라면, 헤더 8바이트를 제외한 412라는 숫자가 헤더에 담겨져 있다.

<태스크의 구조와 설계 한계점>
adc 측정, rmt전송(LED), uart1의 통신, network 통신이 개별 task로 분리되어 있다. 
원래는 parallel하게 동작시켜서 최대 performance를 내게하기 위함이다.
그러나 테스트를 해본 결과, adc 측정, rmt전송, uart 통신을 동시에 동작시키면 데이터가 깨지는 현상이 발견되었다.
그래서 이 세가지는 각각 순차적으로 동작하고 있다.


[4] softap와 mqtt를 활용한 TCP 연결 알고리즘
esp32 장비는 8대가 1개의 세트다. 
PC가 tcp 서버가 되고, esp32 8대는 클라이언트가 된다. 8대의 esp32와 폰은 같은 ap안에 연결이 되어 있다. 
pc의 ip는 wifi ap내부에서 dhcp를 통해서 할당 받게 되는데 이 ip를 esp32에게 알려주기 위해서 mqtt를 사용하게 된다.
일반적으로 mqtt는 서버가 esp32쪽으로 보내는 방향으로 많이 활용되지만, 그 반대의 경우도 미래에는 존재한다.
따라서 PC쪽 서버와 ESP32쪽 모두 Pub/Sub권한을 가지고 있다.

어쨋든 이렇게 esp32 8대+안드로이도폰 1대의 조합을 '진단 세트'라고 부른다.
1개의 공간 안에는 여러개의 진단 세트가 존재할수 있다.

예를 들면 80대의 esp32 단말기와 10대의 pc가 1개의 ap 안에서 연결이 될수가 있다. 총 10개의 '진단 세트'가 동시에 동작하는 셈이다.

이 연결 과정에서 esp32 단말기 입장에서 어떤 tcp서버와 연결해야할지 구분해야 하는데, 그 용도로 Appid가 필요하다.
10대의 안드로이드 폰은 자기 ip를  publishing하는데. 그 토픽을 미리 약속된 AppID로 하는 것이다.
그러면 80대의 esp32 단말기는 10개의 메시지를 동시에 받더라도, AppID를 보고 구분을 하게 된다.

사용자가 softap를 통해 esp32의 wifi ssid, password를 설정할 때에 TCP서버의 AppID를 함께 설정해준다.

그래서 10대의 PC의 10개의 TCP 서버가 동시에 TCP SERVER IP를 broadcasting하더라도 esp32는 자기가 가지고 있는 appid에 대한 tcp server ip를 정확히 받을수 있는 것이다.

[5] TCP 서버쪽 소스코드. 
proc_tcp_mqtt_ota_v03 폴더에 담긴 내용이다.
mqtt를 publishing하는데, 이미 tcp 클라이언트들이 전부 연결이 됐다면, 굳이 더 보낼 필요가 없다. 따라서 버튼을 눌러서 mqtt메시지를 보낼지 말지를 결정한다.
osd data를 전송하는 버튼이 있다. width, height를 설정해서 보내주게 된다.
내가 원하는 client id(보드 번호, 범위는 0~7)를 선택해서 보낼수 있으며. 8로 설정해서 보내면 연결된 모든 보드에게 보내주게 된다.



